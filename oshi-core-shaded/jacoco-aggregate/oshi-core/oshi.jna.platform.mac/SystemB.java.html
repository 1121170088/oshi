<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SystemB.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">oshi-core-shaded</a> &gt; <a href="../index.html" class="el_bundle">oshi-core</a> &gt; <a href="index.source.html" class="el_package">oshi.jna.platform.mac</a> &gt; <span class="el_source">SystemB.java</span></div><h1>SystemB.java</h1><pre class="source lang-java linenums">/**
 * Oshi (https://github.com/oshi/oshi)
 *
 * Copyright (c) 2010 - 2018 The Oshi Project Team
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Maintainers:
 * dblock[at]dblock[dot]org
 * widdis[at]gmail[dot]com
 * enrico.bianchi[at]gmail[dot]com
 *
 * Contributors:
 * https://github.com/oshi/oshi/graphs/contributors
 */
package oshi.jna.platform.mac;

import java.util.Arrays;
import java.util.List;

import com.sun.jna.Native;
import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import com.sun.jna.Structure;
import com.sun.jna.ptr.PointerByReference;

import oshi.jna.platform.unix.CLibrary;

/**
 * Power Supply stats. This class should be considered non-API as it may be
 * removed if/when its code is incorporated into the JNA project.
 *
 * @author widdis[at]gmail[dot]com
 */
public interface SystemB extends CLibrary, com.sun.jna.platform.mac.SystemB {
<span class="nc" id="L39">    SystemB INSTANCE = Native.loadLibrary(&quot;System&quot;, SystemB.class);</span>

    // params.h
    int MAXCOMLEN = 16;
    int MAXPATHLEN = 1024;
    int PROC_PIDPATHINFO_MAXSIZE = MAXPATHLEN * 4;

    // proc_info.h
    int PROC_ALL_PIDS = 1;
    int PROC_PIDTASKALLINFO = 2;
    int PROC_PIDTBSDINFO = 3;
    int PROC_PIDTASKINFO = 4;
    int PROC_PIDVNODEPATHINFO = 9;

    // length of fs type name including null
    int MFSTYPENAMELEN = 16;
    // length of buffer for returned name
    int MNAMELEN = MAXPATHLEN;

    // fsstat paths
    int MNT_WAIT = 0x0001;
    int MNT_NOWAIT = 0x0010;
    int MNT_DWAIT = 0x0100;

    // resource.h
    int RUSAGE_INFO_V2 = 2;

<span class="nc" id="L66">    class ProcTaskAllInfo extends Structure {</span>
        public ProcBsdInfo pbsd;
        public ProcTaskInfo ptinfo;

        @Override
        protected List&lt;String&gt; getFieldOrder() {
<span class="nc" id="L72">            return Arrays.asList(new String[] { &quot;pbsd&quot;, &quot;ptinfo&quot; });</span>
        }
    }

<span class="nc" id="L76">    class ProcBsdInfo extends Structure {</span>
        public int pbi_flags;
        public int pbi_status;
        public int pbi_xstatus;
        public int pbi_pid;
        public int pbi_ppid;
        public int pbi_uid;
        public int pbi_gid;
        public int pbi_ruid;
        public int pbi_rgid;
        public int pbi_svuid;
        public int pbi_svgid;
        public int rfu_1;
<span class="nc" id="L89">        public byte[] pbi_comm = new byte[MAXCOMLEN];</span>
<span class="nc" id="L90">        public byte[] pbi_name = new byte[2 * MAXCOMLEN];</span>
        public int pbi_nfiles;
        public int pbi_pgid;
        public int pbi_pjobc;
        public int e_tdev;
        public int e_tpgid;
        public int pbi_nice;
        public long pbi_start_tvsec;
        public long pbi_start_tvusec;

        @Override
        protected List&lt;String&gt; getFieldOrder() {
<span class="nc" id="L102">            return Arrays.asList(new String[] { &quot;pbi_flags&quot;, &quot;pbi_status&quot;, &quot;pbi_xstatus&quot;, &quot;pbi_pid&quot;, &quot;pbi_ppid&quot;,</span>
                    &quot;pbi_uid&quot;, &quot;pbi_gid&quot;, &quot;pbi_ruid&quot;, &quot;pbi_rgid&quot;, &quot;pbi_svuid&quot;, &quot;pbi_svgid&quot;, &quot;rfu_1&quot;, &quot;pbi_comm&quot;,
                    &quot;pbi_name&quot;, &quot;pbi_nfiles&quot;, &quot;pbi_pgid&quot;, &quot;pbi_pjobc&quot;, &quot;e_tdev&quot;, &quot;e_tpgid&quot;, &quot;pbi_nice&quot;,
                    &quot;pbi_start_tvsec&quot;, &quot;pbi_start_tvusec&quot; });
        }
    }

<span class="nc" id="L109">    class ProcTaskInfo extends Structure {</span>
        public long pti_virtual_size; /* virtual memory size (bytes) */
        public long pti_resident_size; /* resident memory size (bytes) */
        public long pti_total_user; /* total time (nanoseconds) */
        public long pti_total_system;
        public long pti_threads_user; /* existing threads only */
        public long pti_threads_system;
        public int pti_policy; /* default policy for new threads */
        public int pti_faults; /* number of page faults */
        public int pti_pageins; /* number of actual pageins */
        public int pti_cow_faults; /* number of copy-on-write faults */
        public int pti_messages_sent; /* number of messages sent */
        public int pti_messages_received; /* number of messages received */
        public int pti_syscalls_mach; /* number of mach system calls */
        public int pti_syscalls_unix; /* number of unix system calls */
        public int pti_csw; /* number of context switches */
        public int pti_threadnum; /* number of threads in the task */
        public int pti_numrunning; /* number of running threads */
        public int pti_priority; /* task priority */

        @Override
        protected List&lt;String&gt; getFieldOrder() {
<span class="nc" id="L131">            return Arrays.asList(new String[] { &quot;pti_virtual_size&quot;, &quot;pti_resident_size&quot;, &quot;pti_total_user&quot;,</span>
                    &quot;pti_total_system&quot;, &quot;pti_threads_user&quot;, &quot;pti_threads_system&quot;, &quot;pti_policy&quot;, &quot;pti_faults&quot;,
                    &quot;pti_pageins&quot;, &quot;pti_cow_faults&quot;, &quot;pti_messages_sent&quot;, &quot;pti_messages_received&quot;, &quot;pti_syscalls_mach&quot;,
                    &quot;pti_syscalls_unix&quot;, &quot;pti_csw&quot;, &quot;pti_threadnum&quot;, &quot;pti_numrunning&quot;, &quot;pti_priority&quot; });
        }
    }

<span class="nc" id="L138">    class VMMeter extends Structure {</span>
        /*
         * General system activity.
         */
        public int v_swtch; /* context switches */
        public int v_trap; /* calls to trap */
        public int v_syscall; /* calls to syscall() */
        public int v_intr; /* device interrupts */
        public int v_soft; /* software interrupts */
        public int v_faults; /* total faults taken */
        /*
         * Virtual memory activity.
         */
        public int v_lookups; /* object cache lookups */
        public int v_hits; /* object cache hits */
        public int v_vm_faults; /* number of address memory faults */
        public int v_cow_faults; /* number of copy-on-writes */
        public int v_swpin; /* swapins */
        public int v_swpout; /* swapouts */
        public int v_pswpin; /* pages swapped in */
        public int v_pswpout; /* pages swapped out */
        public int v_pageins; /* number of pageins */
        public int v_pageouts; /* number of pageouts */
        public int v_pgpgin; /* pages paged in */
        public int v_pgpgout; /* pages paged out */
        public int v_intrans; /* intransit blocking page faults */
        public int v_reactivated; /*
                                   * number of pages reactivated from free list
                                   */
        public int v_rev; /* revolutions of the hand */
        public int v_scan; /* scans in page out daemon */
        public int v_dfree; /* pages freed by daemon */
        public int v_pfree; /* pages freed by exiting processes */
        public int v_zfod; /* pages zero filled on demand */
        public int v_nzfod; /* number of zfod's created */
        /*
         * Distribution of page usages.
         */
        public int v_page_size; /* page size in bytes */
        public int v_kernel_pages; /* number of pages in use by kernel */
        public int v_free_target; /* number of pages desired free */
        public int v_free_min; /* minimum number of pages desired free */
        public int v_free_count; /* number of pages free */
        public int v_wire_count; /* number of pages wired down */
        public int v_active_count; /* number of pages active */
        public int v_inactive_target; /* number of pages desired inactive */
        public int v_inactive_count; /* number of pages inactive */

        @Override
        protected List&lt;String&gt; getFieldOrder() {
<span class="nc" id="L188">            return Arrays.asList(new String[] { &quot;v_swtch&quot;, &quot;v_trap&quot;, &quot;v_syscall&quot;, &quot;v_intr&quot;, &quot;v_soft&quot;, &quot;v_faults&quot;,</span>
                    &quot;v_lookups&quot;, &quot;v_hits&quot;, &quot;v_vm_faults&quot;, &quot;v_cow_faults&quot;, &quot;v_swpin&quot;, &quot;v_swpout&quot;, &quot;v_pswpin&quot;,
                    &quot;v_pswpout&quot;, &quot;v_pageins&quot;, &quot;v_pageouts&quot;, &quot;v_pgpgin&quot;, &quot;v_pgpgout&quot;, &quot;v_intrans&quot;, &quot;v_reactivated&quot;,
                    &quot;v_rev&quot;, &quot;v_scan&quot;, &quot;v_dfree&quot;, &quot;v_pfree&quot;, &quot;v_zfod&quot;, &quot;v_nzfod&quot;, &quot;v_page_size&quot;, &quot;v_kernel_pages&quot;,
                    &quot;v_free_target&quot;, &quot;v_free_min&quot;, &quot;v_free_count&quot;, &quot;v_wire_count&quot;, &quot;v_active_count&quot;,
                    &quot;v_inactive_target&quot;, &quot;v_inactive_count&quot; });
        }
    }

<span class="nc" id="L197">    class RUsageInfoV2 extends Structure {</span>
<span class="nc" id="L198">        public byte[] ri_uuid = new byte[16];</span>
        public long ri_user_time;
        public long ri_system_time;
        public long ri_pkg_idle_wkups;
        public long ri_interrupt_wkups;
        public long ri_pageins;
        public long ri_wired_size;
        public long ri_resident_size;
        public long ri_phys_footprint;
        public long ri_proc_start_abstime;
        public long ri_proc_exit_abstime;
        public long ri_child_user_time;
        public long ri_child_system_time;
        public long ri_child_pkg_idle_wkups;
        public long ri_child_interrupt_wkups;
        public long ri_child_pageins;
        public long ri_child_elapsed_abstime;
        public long ri_diskio_bytesread;
        public long ri_diskio_byteswritten;

        @Override
        protected List&lt;String&gt; getFieldOrder() {
<span class="nc" id="L220">            return Arrays.asList(new String[] { &quot;ri_uuid&quot;, &quot;ri_user_time&quot;, &quot;ri_system_time&quot;, &quot;ri_pkg_idle_wkups&quot;,</span>
                    &quot;ri_interrupt_wkups&quot;, &quot;ri_pageins&quot;, &quot;ri_wired_size&quot;, &quot;ri_resident_size&quot;, &quot;ri_phys_footprint&quot;,
                    &quot;ri_proc_start_abstime&quot;, &quot;ri_proc_exit_abstime&quot;, &quot;ri_child_user_time&quot;, &quot;ri_child_system_time&quot;,
                    &quot;ri_child_pkg_idle_wkups&quot;, &quot;ri_child_interrupt_wkups&quot;, &quot;ri_child_pageins&quot;,
                    &quot;ri_child_elapsed_abstime&quot;, &quot;ri_diskio_bytesread&quot;, &quot;ri_diskio_byteswritten&quot; });
        }
    }

<span class="nc" id="L228">    class VnodeInfoPath extends Structure {</span>
<span class="nc" id="L229">        public byte[] vip_vi = new byte[152]; // vnode_info but we don't</span>
                                              // need its data
<span class="nc" id="L231">        public byte[] vip_path = new byte[MAXPATHLEN];</span>

        @Override
        protected List&lt;String&gt; getFieldOrder() {
<span class="nc" id="L235">            return Arrays.asList(new String[] { &quot;vip_vi&quot;, &quot;vip_path&quot; });</span>
        }
    }

<span class="nc" id="L239">    class VnodePathInfo extends Structure {</span>
        public VnodeInfoPath pvi_cdir;
        public VnodeInfoPath pvi_rdir;

        @Override
        protected List&lt;String&gt; getFieldOrder() {
<span class="nc" id="L245">            return Arrays.asList(new String[] { &quot;pvi_cdir&quot;, &quot;pvi_rdir&quot; });</span>
        }
    }

    /**
     * The statfs() routine returns information about a mounted file system. The
     * path argument is the path name of any file or directory within the
     * mounted file system. The buf argument is a pointer to a statfs structure.
     */
<span class="nc" id="L254">    class Statfs extends Structure {</span>
        public int f_bsize; /* fundamental file system block size */
        public int f_iosize; /* optimal transfer block size */
        public long f_blocks; /* total data blocks in file system */
        public long f_bfree; /* free blocks in fs */
        public long f_bavail; /* free blocks avail to non-superuser */
        public long f_files; /* total file nodes in file system */
        public long f_ffree; /* free file nodes in fs */
<span class="nc" id="L262">        public int[] f_fsid = new int[2]; /* file system id */</span>
        public int f_owner; /* user that mounted the filesystem */
        public int f_type; /* type of filesystem */
        public int f_flags; /* copy of mount exported flags */
        public int f_fssubtype; /* fs sub-type (flavor) */
        /* fs type name */
<span class="nc" id="L268">        public byte[] f_fstypename = new byte[MFSTYPENAMELEN];</span>
        /* directory on which mounted */
<span class="nc" id="L270">        public byte[] f_mntonname = new byte[MAXPATHLEN];</span>
        /* mounted filesystem */
<span class="nc" id="L272">        public byte[] f_mntfromname = new byte[MAXPATHLEN];</span>
<span class="nc" id="L273">        public int[] f_reserved = new int[8]; /* For future use */</span>

        @Override
        protected List&lt;String&gt; getFieldOrder() {
<span class="nc" id="L277">            return Arrays.asList(new String[] { &quot;f_bsize&quot;, &quot;f_iosize&quot;, &quot;f_blocks&quot;, &quot;f_bfree&quot;, &quot;f_bavail&quot;, &quot;f_files&quot;,</span>
                    &quot;f_ffree&quot;, &quot;f_fsid&quot;, &quot;f_owner&quot;, &quot;f_type&quot;, &quot;f_flags&quot;, &quot;f_fssubtype&quot;, &quot;f_fstypename&quot;, &quot;f_mntonname&quot;,
                    &quot;f_mntfromname&quot;, &quot;f_reserved&quot; });
        }
    }

    /**
     * Return type for sysctl vm.swapusage
     */
<span class="nc" id="L286">    class XswUsage extends Structure {</span>
        public long xsu_total;
        public long xsu_avail;
        public long xsu_used;
        public int xsu_pagesize;
        public boolean xsu_encrypted;

        @Override
        protected List&lt;String&gt; getFieldOrder() {
<span class="nc" id="L295">            return Arrays</span>
<span class="nc" id="L296">                    .asList(new String[] { &quot;xsu_total&quot;, &quot;xsu_avail&quot;, &quot;xsu_used&quot;, &quot;xsu_pagesize&quot;, &quot;xsu_encrypted&quot; });</span>
        }
    }

    /**
     * Data type as part of IFmsgHdr
     */
<span class="nc" id="L303">    class IFdata extends Structure {</span>
        public byte ifi_type; // ethernet, tokenring, etc
        public byte ifi_typelen; // Length of frame type id
        public byte ifi_physical; // e.g., AUI, Thinnet, 10base-T, etc
        public byte ifi_addrlen; // media address length
        public byte ifi_hdrlen; // media header length
        public byte ifi_recvquota; // polling quota for receive intrs
        public byte ifi_xmitquota; // polling quota for xmit intrs
        public byte ifi_unused1; // for future use
        public int ifi_mtu; // maximum transmission unit
        public int ifi_metric; // routing metric (external only)
        public int ifi_baudrate; // linespeed
        public int ifi_ipackets; // packets received on interface
        public int ifi_ierrors; // input errors on interface
        public int ifi_opackets; // packets sent on interface
        public int ifi_oerrors; // output errors on interface
        public int ifi_collisions; // collisions on csma interfaces
        public int ifi_ibytes; // total number of octets received
        public int ifi_obytes; // total number of octets sent
        public int ifi_imcasts; // packets received via multicast
        public int ifi_omcasts; // packets sent via multicast
        public int ifi_iqdrops; // dropped on input, this interface
        public int ifi_noproto; // destined for unsupported protocol
        public int ifi_recvtiming; // usec spent receiving when timing
        public int ifi_xmittiming; // usec spent xmitting when timing
        public Timeval ifi_lastchange; // time of last administrative change
        public int ifi_unused2; // used to be the default_proto
        public int ifi_hwassist; // HW offload capabilities
        public int ifi_reserved1; // for future use
        public int ifi_reserved2; // for future use

        @Override
        protected List&lt;String&gt; getFieldOrder() {
<span class="nc" id="L336">            return Arrays.asList(new String[] { &quot;ifi_type&quot;, &quot;ifi_typelen&quot;, &quot;ifi_physical&quot;, &quot;ifi_addrlen&quot;, &quot;ifi_hdrlen&quot;,</span>
                    &quot;ifi_recvquota&quot;, &quot;ifi_xmitquota&quot;, &quot;ifi_unused1&quot;, &quot;ifi_mtu&quot;, &quot;ifi_metric&quot;, &quot;ifi_baudrate&quot;,
                    &quot;ifi_ipackets&quot;, &quot;ifi_ierrors&quot;, &quot;ifi_opackets&quot;, &quot;ifi_oerrors&quot;, &quot;ifi_collisions&quot;, &quot;ifi_ibytes&quot;,
                    &quot;ifi_obytes&quot;, &quot;ifi_imcasts&quot;, &quot;ifi_omcasts&quot;, &quot;ifi_iqdrops&quot;, &quot;ifi_noproto&quot;, &quot;ifi_recvtiming&quot;,
                    &quot;ifi_xmittiming&quot;, &quot;ifi_lastchange&quot;, &quot;ifi_unused2&quot;, &quot;ifi_hwassist&quot;, &quot;ifi_reserved1&quot;,
                    &quot;ifi_reserved2&quot; });
        }
    }

    /**
     * Return type for sysctl CTL_NET,PF_ROUTE
     */
    class IFmsgHdr extends Structure {
        public short ifm_msglen; // to skip over non-understood messages
        public byte ifm_version; // future binary compatability
        public byte ifm_type; // message type
        public int ifm_addrs; // like rtm_addrs
        public int ifm_flags; // value of if_flags
        public short ifm_index; // index for associated ifp
        public IFdata ifm_data; // statistics and other data about if

        public IFmsgHdr() {
<span class="nc" id="L358">            super();</span>
<span class="nc" id="L359">        }</span>

        public IFmsgHdr(Pointer p) {
<span class="nc" id="L362">            super(p);</span>
<span class="nc" id="L363">        }</span>

        @Override
        protected List&lt;String&gt; getFieldOrder() {
<span class="nc" id="L367">            return Arrays.asList(new String[] { &quot;ifm_msglen&quot;, &quot;ifm_version&quot;, &quot;ifm_type&quot;, &quot;ifm_addrs&quot;, &quot;ifm_flags&quot;,</span>
                    &quot;ifm_index&quot;, &quot;ifm_data&quot; });
        }
    }

    /**
     * Data type as part of IFmsgHdr
     */
<span class="nc" id="L375">    class IFdata64 extends Structure {</span>
        public byte ifi_type; // ethernet, tokenring, etc
        public byte ifi_typelen; // Length of frame type id
        public byte ifi_physical; // e.g., AUI, Thinnet, 10base-T, etc
        public byte ifi_addrlen; // media address length
        public byte ifi_hdrlen; // media header length
        public byte ifi_recvquota; // polling quota for receive intrs
        public byte ifi_xmitquota; // polling quota for xmit intrs
        public byte ifi_unused1; // for future use
        public int ifi_mtu; // maximum transmission unit
        public int ifi_metric; // routing metric (external only)
        public long ifi_baudrate; // linespeed
        public long ifi_ipackets; // packets received on interface
        public long ifi_ierrors; // input errors on interface
        public long ifi_opackets; // packets sent on interface
        public long ifi_oerrors; // output errors on interface
        public long ifi_collisions; // collisions on csma interfaces
        public long ifi_ibytes; // total number of octets received
        public long ifi_obytes; // total number of octets sent
        public long ifi_imcasts; // packets received via multicast
        public long ifi_omcasts; // packets sent via multicast
        public long ifi_iqdrops; // dropped on input, this interface
        public long ifi_noproto; // destined for unsupported protocol
        public int ifi_recvtiming; // usec spent receiving when timing
        public int ifi_xmittiming; // usec spent xmitting when timing
        public Timeval ifi_lastchange; // time of last administrative change

        @Override
        protected List&lt;String&gt; getFieldOrder() {
<span class="nc" id="L404">            return Arrays.asList(new String[] { &quot;ifi_type&quot;, &quot;ifi_typelen&quot;, &quot;ifi_physical&quot;, &quot;ifi_addrlen&quot;, &quot;ifi_hdrlen&quot;,</span>
                    &quot;ifi_recvquota&quot;, &quot;ifi_xmitquota&quot;, &quot;ifi_unused1&quot;, &quot;ifi_mtu&quot;, &quot;ifi_metric&quot;, &quot;ifi_baudrate&quot;,
                    &quot;ifi_ipackets&quot;, &quot;ifi_ierrors&quot;, &quot;ifi_opackets&quot;, &quot;ifi_oerrors&quot;, &quot;ifi_collisions&quot;, &quot;ifi_ibytes&quot;,
                    &quot;ifi_obytes&quot;, &quot;ifi_imcasts&quot;, &quot;ifi_omcasts&quot;, &quot;ifi_iqdrops&quot;, &quot;ifi_noproto&quot;, &quot;ifi_recvtiming&quot;,
                    &quot;ifi_xmittiming&quot;, &quot;ifi_lastchange&quot; });
        }
    }

    /**
     * Return type for sysctl CTL_NET,PF_ROUTE
     */
    class IFmsgHdr2 extends Structure {
        public short ifm_msglen; // to skip over non-understood messages
        public byte ifm_version; // future binary compatability
        public byte ifm_type; // message type
        public int ifm_addrs; // like rtm_addrs
        public int ifm_flags; // value of if_flags
        public short ifm_index; // index for associated ifp
        public int ifm_snd_len; // instantaneous length of send queue
        public int ifm_snd_maxlen; // maximum length of send queue
        public int ifm_snd_drops; // number of drops in send queue
        public int ifm_timer; // time until if_watchdog called
        public IFdata64 ifm_data; // statistics and other data about if

        public IFmsgHdr2(Pointer p) {
<span class="nc" id="L429">            super(p);</span>
<span class="nc" id="L430">        }</span>

        @Override
        protected List&lt;String&gt; getFieldOrder() {
<span class="nc" id="L434">            return Arrays.asList(new String[] { &quot;ifm_msglen&quot;, &quot;ifm_version&quot;, &quot;ifm_type&quot;, &quot;ifm_addrs&quot;, &quot;ifm_flags&quot;,</span>
                    &quot;ifm_index&quot;, &quot;ifm_snd_len&quot;, &quot;ifm_snd_maxlen&quot;, &quot;ifm_snd_drops&quot;, &quot;ifm_timer&quot;, &quot;ifm_data&quot; });
        }
    }

    /**
     * Return type for getpwuid
     */
<span class="nc" id="L442">    class Passwd extends Structure {</span>
        public String pw_name; // user name
        public String pw_passwd; // encrypted password
        public int pw_uid; // user uid
        public int pw_gid; // user gid
        public NativeLong pw_change; // password change time
        public String pw_class; // user access class
        public String pw_gecos; // Honeywell login info
        public String pw_dir; // home directory
        public String pw_shell; // default shell
        public NativeLong pw_expire; // account expiration
        public int pw_fields; // internal: fields filled in

        @Override
        protected List&lt;String&gt; getFieldOrder() {
<span class="nc" id="L457">            return Arrays.asList(new String[] { &quot;pw_name&quot;, &quot;pw_passwd&quot;, &quot;pw_uid&quot;, &quot;pw_gid&quot;, &quot;pw_change&quot;, &quot;pw_class&quot;,</span>
                    &quot;pw_gecos&quot;, &quot;pw_dir&quot;, &quot;pw_shell&quot;, &quot;pw_expire&quot;, &quot;pw_fields&quot; });
        }
    }

    /**
     * Return type for getgrgid
     */
<span class="nc" id="L465">    class Group extends Structure {</span>
        public String gr_name; /* group name */
        public String gr_passwd; /* group password */
        public int gr_gid; /* group id */
        public PointerByReference gr_mem; /* group members */

        @Override
        protected List&lt;String&gt; getFieldOrder() {
<span class="nc" id="L473">            return Arrays.asList(new String[] { &quot;gr_name&quot;, &quot;gr_passwd&quot;, &quot;gr_gid&quot;, &quot;gr_mem&quot; });</span>
        }
    }

    /**
     * This function searches the password database for the given user uid,
     * always returning the first one encountered.
     *
     * @param uid
     *            The user ID
     * @return a Passwd structure matching that user
     */
    Passwd getpwuid(int uid);

    /**
     * This function searches the group database for the given group name
     * pointed to by the group id given by gid, returning the first one
     * encountered. Identical group gids may result in undefined behavior.
     *
     * @param gid
     *            The group ID
     * @return a Group structure matching that group
     */
    Group getgrgid(int gid);

    /**
     * Search through the current processes
     *
     * @param type
     *            types of processes to be searched
     * @param typeinfo
     *            adjunct information for type
     * @param buffer
     *            a C array of int-sized values to be filled with process
     *            identifiers that hold an open file reference matching the
     *            specified path or volume. Pass NULL to obtain the minimum
     *            buffer size needed to hold the currently active processes.
     * @param buffersize
     *            the size (in bytes) of the provided buffer.
     * @return the number of bytes of data returned in the provided buffer; -1
     *         if an error was encountered;
     */
    int proc_listpids(int type, int typeinfo, int[] buffer, int buffersize);

    /**
     * Return in buffer a proc_*info structure corresponding to the flavor for
     * the specified process
     *
     * @param pid
     *            the process identifier
     * @param flavor
     *            the type of information requested
     * @param arg
     *            argument possibly needed for some flavors
     * @param buffer
     *            holds results
     * @param buffersize
     *            size of results
     * @return the number of bytes of data returned in the provided buffer; -1
     *         if an error was encountered;
     */
    int proc_pidinfo(int pid, int flavor, long arg, Structure buffer, int buffersize);

    /**
     * Return in buffer the name of the specified process
     *
     * @param pid
     *            the process identifier
     * @param buffer
     *            holds results
     * @param buffersize
     *            size of results
     * @return the length of the name returned in buffer if successful; 0
     *         otherwise
     */
    int proc_pidpath(int pid, Pointer buffer, int buffersize);

    /**
     * Return resource usage information for the given pid, which can be a live
     * process or a zombie.
     *
     * @param pid
     *            the process identifier
     * @param flavor
     *            the type of information requested
     * @param buffer
     *            holds results
     * @return 0 on success; or -1 on failure, with errno set to indicate the
     *         specific error.
     */
    int proc_pid_rusage(int pid, int flavor, RUsageInfoV2 buffer);

    /**
     * The getfsstat() function returns information about all mounted file
     * systems. The buf argument is a pointer to an array of statfs structures.
     *
     * Fields that are undefined for a particular file system are set to -1. The
     * buffer is filled with an array of statfs structures, one for each mounted
     * file system up to the size specified by bufsize.
     *
     * @param buf
     *            Array of statfs structures that will be filled with results.
     *            If buf is given as NULL, getfsstat() returns just the number
     *            of mounted file systems.
     * @param bufsize
     *            Size of the buffer to fill
     * @param flags
     *            If flags is set to MNT_NOWAIT, getfsstat() will directly
     *            return the information retained in the kernel to avoid delays
     *            caused by waiting for updated information from a file system
     *            that is perhaps temporarily unable to respond. Some of the
     *            information returned may be out of date, however; if flags is
     *            set to MNT_WAIT or MNT_DWAIT instead, getfsstat() will request
     *            updated information from each mounted filesystem before
     *            returning.
     * @return Upon successful completion, the number of statfs structures is
     *         returned. Otherwise, -1 is returned and the global variable errno
     *         is set to indicate the error.
     */
    int getfsstat64(Statfs[] buf, int bufsize, int flags);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.1.201803210924</span></div></body></html>