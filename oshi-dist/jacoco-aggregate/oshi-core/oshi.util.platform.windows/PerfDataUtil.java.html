<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>PerfDataUtil.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">oshi-dist</a> &gt; <a href="../index.html" class="el_bundle">oshi-core</a> &gt; <a href="index.source.html" class="el_package">oshi.util.platform.windows</a> &gt; <span class="el_source">PerfDataUtil.java</span></div><h1>PerfDataUtil.java</h1><pre class="source lang-java linenums">/**
 * Oshi (https://github.com/oshi/oshi)
 *
 * Copyright (c) 2010 - 2018 The Oshi Project Team
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Maintainers:
 * dblock[at]dblock[dot]org
 * widdis[at]gmail[dot]com
 * enrico.bianchi[at]gmail[dot]com
 *
 * Contributors:
 * https://github.com/oshi/oshi/graphs/contributors
 */
package oshi.util.platform.windows;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TimeZone;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.sun.jna.platform.win32.BaseTSD.DWORD_PTR; // NOSONAR
import com.sun.jna.platform.win32.Pdh;
import com.sun.jna.platform.win32.Pdh.PDH_RAW_COUNTER;
import com.sun.jna.platform.win32.PdhMsg;
import com.sun.jna.platform.win32.WinDef.DWORD;
import com.sun.jna.platform.win32.WinDef.DWORDByReference;
import com.sun.jna.platform.win32.WinDef.LONGLONGByReference;
import com.sun.jna.platform.win32.WinError;
import com.sun.jna.platform.win32.WinNT;
import com.sun.jna.platform.win32.WinNT.HANDLEByReference;

/**
 * Helper class to centralize the boilerplate portions of PDH counter setup and
 * allow applications to easily add, query, and remove counters.
 *
 * @author widdis[at]gmail[dot]com
 */
public class PerfDataUtil {
    /**
     * Instance to generate the PerfCounter class.
     */
<span class="nc" id="L53">    public static final PerfDataUtil INSTANCE = new PerfDataUtil();</span>

<span class="nc" id="L55">    private static final Logger LOG = LoggerFactory.getLogger(PerfDataUtil.class);</span>

<span class="nc" id="L57">    private static final DWORD_PTR PZERO = new DWORD_PTR(0);</span>
<span class="nc" id="L58">    private static final DWORDByReference PDH_FMT_RAW = new DWORDByReference(new DWORD(Pdh.PDH_FMT_RAW));</span>
<span class="nc" id="L59">    private static final Pdh PDH = Pdh.INSTANCE;</span>

    private static final String HEX_ERROR_FMT = &quot;0x%08X&quot;;
    private static final String LOG_COUNTER_NOT_EXISTS = &quot;Counter does not exist: {}&quot;;
    private static final String LOG_COUNTER_RECREATE = &quot;Removing and re-adding counter: {}&quot;;

    // PDH timestamps are 1601 epoch, local time
    // Constants to convert to UTC millis
    private static final long EPOCH_DIFF = 11644473600000L;
<span class="nc" id="L68">    private static final int TZ_OFFSET = TimeZone.getDefault().getOffset(System.currentTimeMillis());</span>

    // Maps to hold pointers to the relevant counter information
<span class="nc" id="L71">    private static final Map&lt;PerfCounter, HANDLEByReference&gt; counterMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L72">    private static final Map&lt;String, HANDLEByReference&gt; queryMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L73">    private static final Set&lt;String&gt; disabledQueries = new HashSet&lt;&gt;();</span>

    public class PerfCounter {
        private String object;
        private String instance;
        private String counter;

<span class="nc" id="L80">        public PerfCounter(String objectName, String instanceName, String counterName) {</span>
<span class="nc" id="L81">            this.object = objectName;</span>
<span class="nc" id="L82">            this.instance = instanceName;</span>
<span class="nc" id="L83">            this.counter = counterName;</span>
<span class="nc" id="L84">        }</span>
    }

<span class="nc" id="L87">    private PerfDataUtil() {</span>
        // Set up hook to close all queries on shutdown
<span class="nc" id="L89">        Runtime.getRuntime().addShutdownHook(new Thread() {</span>
            @Override
            public void run() {
<span class="nc" id="L92">                removeAllCounters();</span>
<span class="nc" id="L93">            }</span>
        });
<span class="nc" id="L95">    }</span>

    /**
     * Create a Performance Counter
     *
     * @param object
     *            The object/path for the counter
     * @param instance
     *            The instance of the counter, or null if no instance
     * @param counter
     *            The counter name
     * @return A PerfCounter object encapsulating the object, instance, and
     *         counter
     */
    public static PerfCounter createCounter(String object, String instance, String counter) {
<span class="nc" id="L110">        return INSTANCE.new PerfCounter(object, instance, counter);</span>
    }

    /**
     * Begin monitoring a Performance Data counter
     *
     * @param counter
     *            A PerfCounter object
     * @return True if the counter was successfully added.
     */
    public static boolean addCounterToQuery(PerfCounter counter) {
<span class="nc" id="L121">        HANDLEByReference q = openQuery(counter.object);</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">        if (q == null) {</span>
<span class="nc" id="L123">            LOG.error(&quot;Failed to open a query for PDH object: {}&quot;, counter.object);</span>
<span class="nc" id="L124">            return false;</span>
        }
<span class="nc" id="L126">        HANDLEByReference p = new HANDLEByReference();</span>
<span class="nc" id="L127">        String path = counterPath(counter);</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">        if (addCounter(q, path, p)) {</span>
<span class="nc" id="L129">            counterMap.put(counter, p);</span>
<span class="nc" id="L130">            return true;</span>
        }
<span class="nc" id="L132">        return false;</span>
    }

    /**
     * Stop monitoring a Performance Data counter
     *
     * @param counter
     *            A PerfCounter object
     * @return True if the counter was successfully removed.
     */
    public static boolean removeCounterFromQuery(PerfCounter counter) {
<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (counterMap.containsKey(counter)) {</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">            return WinError.ERROR_SUCCESS == PDH.PdhRemoveCounter(counterMap.get(counter).getValue());</span>
        }
<span class="nc" id="L146">        return false;</span>
    }

    /**
     * Update a counter, and all other counters on that object
     *
     * @param counter
     *            The counter whose object to update counters on
     * @return The timestamp for the update of all the counters, in milliseconds
     *         since the epoch, or 0 if the update failed
     */
    public static long updateQuery(PerfCounter counter) {
<span class="nc bnc" id="L158" title="All 2 branches missed.">        if (disabledQueries.contains(counter.object)) {</span>
<span class="nc" id="L159">            return 0L;</span>
        }
<span class="nc bnc" id="L161" title="All 4 branches missed.">        if (!queryMap.containsKey(counter.object) || !counterMap.containsKey(counter)) {</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">            if (LOG.isErrorEnabled()) {</span>
<span class="nc" id="L163">                LOG.error(LOG_COUNTER_NOT_EXISTS, counterPath(counter));</span>
            }
<span class="nc" id="L165">            return 0L;</span>
        }
<span class="nc" id="L167">        long timestamp = updateQueryTimestamp(queryMap.get(counter.object));</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">        if (timestamp == 0L) {</span>
<span class="nc" id="L169">            LOG.error(&quot;Disabling future updates for {}.&quot;, counter.object);</span>
<span class="nc" id="L170">            disabledQueries.add(counter.object);</span>
<span class="nc" id="L171">            return 0L;</span>
        }
<span class="nc" id="L173">        return timestamp;</span>
    }

    /**
     * Update all counters on an object
     *
     * @param queryKey
     *            The counter object to update counters on
     * @return The timestamp for the update of all the counters, in milliseconds
     *         since the epoch, or 0 if the update failed
     */
    public static long updateQuery(String queryKey) {
<span class="nc bnc" id="L185" title="All 4 branches missed.">        if (disabledQueries.contains(queryKey) || !queryMap.containsKey(queryKey)) {</span>
<span class="nc" id="L186">            return 0L;</span>
        }
<span class="nc" id="L188">        return updateQueryTimestamp(queryMap.get(queryKey));</span>
    }

    /**
     * Query the raw counter value of a Performance Data counter. Further
     * mathematical manipulation/conversion is left to the caller.
     *
     * @param counter
     *            The counter to query
     * @return The raw value of the counter
     */
    public static long queryCounter(PerfCounter counter) {
<span class="nc bnc" id="L200" title="All 4 branches missed.">        if (!queryMap.containsKey(counter.object) || !counterMap.containsKey(counter)) {</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">            if (LOG.isErrorEnabled()) {</span>
<span class="nc" id="L202">                LOG.error(LOG_COUNTER_NOT_EXISTS, counterPath(counter));</span>
            }
<span class="nc" id="L204">            return 0;</span>
        }
<span class="nc" id="L206">        long value = queryCounter(counterMap.get(counter));</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (value &lt; 0) {</span>
            // Nevative value is error code.
<span class="nc bnc" id="L209" title="All 2 branches missed.">            if (value == PdhMsg.PDH_INVALID_HANDLE) {</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">                if (LOG.isWarnEnabled()) {</span>
<span class="nc" id="L211">                    LOG.warn(LOG_COUNTER_RECREATE, counterPath(counter));</span>
                }
<span class="nc" id="L213">                removeCounterFromQuery(counter);</span>
<span class="nc" id="L214">                addCounterToQuery(counter);</span>
            }
<span class="nc" id="L216">            return 0;</span>
        }
<span class="nc" id="L218">        return value;</span>
    }

    /**
     * Stop monitoring Performance Data counters for a particular queryKey and
     * release their resources
     *
     * @param queryKey
     *            The counter object to remove counters from
     */
    public static void removeAllCounters(String queryKey) {
        // Remove counters from query
<span class="nc" id="L230">        Iterator&lt;Entry&lt;PerfCounter, HANDLEByReference&gt;&gt; it = counterMap.entrySet().iterator();</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L232">            Entry&lt;PerfCounter, HANDLEByReference&gt; entry = it.next();</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">            if (entry.getKey().object.equals(queryKey)) {</span>
<span class="nc" id="L234">                PDH.PdhRemoveCounter(entry.getValue().getValue());</span>
<span class="nc" id="L235">                it.remove();</span>
            }
<span class="nc" id="L237">        }</span>
        // Remove query
<span class="nc" id="L239">        HANDLEByReference query = queryMap.get(queryKey);</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (query != null) {</span>
<span class="nc" id="L241">            PDH.PdhCloseQuery(query.getValue());</span>
        }
<span class="nc" id="L243">        queryMap.remove(queryKey);</span>
<span class="nc" id="L244">        disabledQueries.remove(queryKey);</span>
<span class="nc" id="L245">    }</span>

    /**
     * Open a query for the given string, or confirm a query is already open for
     * that string. Multiple counters may be added to this string, but will all
     * be queried at the same time.
     *
     * @param objectName
     *            String to associate with the counter. Normally the English PDH
     *            object name.
     * @return A handle to the query, or null if an error occurred.
     */
    private static HANDLEByReference openQuery(String objectName) {
<span class="nc bnc" id="L258" title="All 2 branches missed.">        if (queryMap.containsKey(objectName)) {</span>
<span class="nc" id="L259">            return queryMap.get(objectName);</span>
        }
<span class="nc" id="L261">        HANDLEByReference q = new HANDLEByReference();</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (openQuery(q)) {</span>
<span class="nc" id="L263">            queryMap.put(objectName, q);</span>
<span class="nc" id="L264">            return q;</span>
        }
<span class="nc" id="L266">        return null;</span>
    }

    /**
     * Build a counter path
     *
     * counter A Counter object with the object, counter, and (optional)
     * instance
     *
     * @return A string representing the complete counter
     */
    private static String counterPath(PerfCounter counter) {
<span class="nc" id="L278">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L279">        sb.append('\\').append(counter.object);</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">        if (counter.instance != null) {</span>
<span class="nc" id="L281">            sb.append('(').append(counter.instance).append(')');</span>
        }
<span class="nc" id="L283">        sb.append('\\').append(counter.counter);</span>
<span class="nc" id="L284">        return sb.toString();</span>
    }

    /**
     * Stop monitoring all Performance Data counters and release their resources
     */
    public static void removeAllCounters() {
<span class="nc" id="L291">        Set&lt;String&gt; queries = new HashSet&lt;&gt;(queryMap.keySet());</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        for (String query : queries) {</span>
<span class="nc" id="L293">            removeAllCounters(query);</span>
<span class="nc" id="L294">        }</span>
<span class="nc" id="L295">    }</span>

    /**
     * Open a pdh query
     *
     * @param q
     *            pointer to the query
     * @return true if successful
     */
    private static boolean openQuery(HANDLEByReference q) {
<span class="nc" id="L305">        int pdhOpenQueryError = PDH.PdhOpenQuery(null, PZERO, q);</span>
<span class="nc bnc" id="L306" title="All 4 branches missed.">        if (pdhOpenQueryError != WinError.ERROR_SUCCESS &amp;&amp; LOG.isErrorEnabled()) {</span>
<span class="nc" id="L307">            LOG.error(&quot;Failed to open PDH Query. Error code: {}&quot;, String.format(HEX_ERROR_FMT, pdhOpenQueryError));</span>
        }
<span class="nc bnc" id="L309" title="All 2 branches missed.">        return pdhOpenQueryError == WinError.ERROR_SUCCESS;</span>
    }

    /**
     * Adds a pdh counter to a query
     *
     * @param query
     *            Pointer to the query to add the counter
     * @param path
     *            String name of the PerfMon counter
     * @param p
     *            Pointer to the counter
     * @return
     */
    private static boolean addCounter(WinNT.HANDLEByReference query, String path, WinNT.HANDLEByReference p) {
<span class="nc" id="L324">        int pdhAddCounterError = PDH.PdhAddEnglishCounter(query.getValue(), path, PZERO, p);</span>
<span class="nc bnc" id="L325" title="All 4 branches missed.">        if (pdhAddCounterError != WinError.ERROR_SUCCESS &amp;&amp; LOG.isWarnEnabled()) {</span>
<span class="nc" id="L326">            LOG.warn(&quot;Failed to add PDH Counter: {}, Error code: {}&quot;, path,</span>
<span class="nc" id="L327">                    String.format(HEX_ERROR_FMT, pdhAddCounterError));</span>
        }
<span class="nc bnc" id="L329" title="All 2 branches missed.">        return pdhAddCounterError == WinError.ERROR_SUCCESS;</span>
    }

    /**
     * Get value of pdh counter
     *
     * @param counter
     *            The counter to get the value of
     * @return long value of the counter, or negative value representing an
     *         error code
     */
    private static long queryCounter(WinNT.HANDLEByReference counter) {
<span class="nc" id="L341">        PDH_RAW_COUNTER counterValue = new PDH_RAW_COUNTER();</span>
<span class="nc" id="L342">        int ret = PDH.PdhGetRawCounterValue(counter.getValue(), PDH_FMT_RAW, counterValue);</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (ret != WinError.ERROR_SUCCESS) {</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">            if (LOG.isWarnEnabled()) {</span>
<span class="nc" id="L345">                LOG.warn(&quot;Failed to get counter. Error code: {}&quot;, String.format(HEX_ERROR_FMT, ret));</span>
            }
            // Return error code as a negative value
<span class="nc" id="L348">            return -1L * ret;</span>
        }
<span class="nc" id="L350">        return counterValue.FirstValue;</span>
    }

    /**
     * Update a query and get the timestamp
     *
     * @param query
     *            The query to update all counters in
     * @return The update timestamp of the first counter in the query
     */
    private static long updateQueryTimestamp(WinNT.HANDLEByReference query) {
<span class="nc" id="L361">        LONGLONGByReference pllTimeStamp = new LONGLONGByReference();</span>
<span class="nc" id="L362">        int ret = PDH.PdhCollectQueryDataWithTime(query.getValue(), pllTimeStamp);</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (ret != WinError.ERROR_SUCCESS) {</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">            if (LOG.isWarnEnabled()) {</span>
<span class="nc" id="L365">                LOG.warn(&quot;Failed to update counter. Error code: {}&quot;, String.format(HEX_ERROR_FMT, ret));</span>
            }
<span class="nc" id="L367">            return 0;</span>
        }
        // Perf Counter timestamp is in local time
<span class="nc" id="L370">        return filetimeToUtcMs(pllTimeStamp.getValue().longValue(), true);</span>
    }

    /**
     * Convert a long representing filetime (100-ns since 1601 epoch) to ms
     * since 1970 epoch
     *
     * @param filetime
     *            A 64-bit value equivalent to FILETIME
     * @param local
     *            True if converting from a local filetime (PDH counter); false
     *            if already UTC (WMI PerfRawData classes)
     * @return Equivalent milliseconds since the epoch
     */
    public static long filetimeToUtcMs(long filetime, boolean local) {
<span class="nc bnc" id="L385" title="All 2 branches missed.">        return filetime / 10000L - EPOCH_DIFF - (local ? TZ_OFFSET : 0L);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>