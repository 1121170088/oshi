<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SolarisDisks.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">oshi-dist</a> &gt; <a href="../index.html" class="el_bundle">oshi-core</a> &gt; <a href="index.source.html" class="el_package">oshi.hardware.platform.unix.solaris</a> &gt; <span class="el_source">SolarisDisks.java</span></div><h1>SolarisDisks.java</h1><pre class="source lang-java linenums">/**
 * Oshi (https://github.com/dblock/oshi)
 *
 * Copyright (c) 2010 - 2016 The Oshi Project Team
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Maintainers:
 * dblock[at]dblock[dot]org
 * widdis[at]gmail[dot]com
 * enrico.bianchi[at]gmail[dot]com
 *
 * Contributors:
 * https://github.com/dblock/oshi/graphs/contributors
 */
package oshi.hardware.platform.unix.solaris;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

import oshi.hardware.HWDiskStore;
import oshi.hardware.common.AbstractDisks;
import oshi.util.ExecutingCommand;
import oshi.util.ParseUtil;

/**
 * Solaris hard disk implementation.
 *
 * @author widdis[at]gmail[dot]com
 */
<span class="nc" id="L36">public class SolarisDisks extends AbstractDisks {</span>

    private static final long serialVersionUID = 1L;

    @Override
    public HWDiskStore[] getDisks() {
        // Create map indexed by device name for multiple command reference
<span class="nc" id="L43">        Map&lt;String, HWDiskStore&gt; diskMap = new HashMap&lt;&gt;();</span>

        // First, run iostat -er to enumerate disks by name. Sample output:
<span class="nc" id="L46">        ArrayList&lt;String&gt; disks = ExecutingCommand.runNative(&quot;iostat -er&quot;);</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">        for (String line : disks) {</span>
            // The -r switch enables comma delimited for easy parsing!
<span class="nc" id="L49">            String[] split = line.split(&quot;,&quot;);</span>
<span class="nc bnc" id="L50" title="All 4 branches missed.">            if (split.length &lt; 5 || split[0].equals(&quot;device&quot;)) {</span>
<span class="nc" id="L51">                continue;</span>
            }
<span class="nc" id="L53">            HWDiskStore store = new HWDiskStore();</span>
<span class="nc" id="L54">            store.setName(split[0]);</span>
<span class="nc" id="L55">            diskMap.put(split[0], store);</span>
<span class="nc" id="L56">        }</span>

        // Next, run iostat -Er to get model, etc.
<span class="nc" id="L59">        disks = ExecutingCommand.runNative(&quot;iostat -Er&quot;);</span>
        // We'll use Model if available, otherwise Vendor+Product
<span class="nc" id="L61">        String disk = &quot;&quot;;</span>
<span class="nc" id="L62">        String model = &quot;&quot;;</span>
<span class="nc" id="L63">        String vendor = &quot;&quot;;</span>
<span class="nc" id="L64">        String product = &quot;&quot;;</span>
<span class="nc" id="L65">        String serial = &quot;&quot;;</span>
<span class="nc" id="L66">        long size = 0;</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">        for (String line : disks) {</span>
            // The -r switch enables comma delimited for easy parsing!
            // No guarantees on which line the results appear so we'll nest
            // a loop iterating on the comma splits
<span class="nc" id="L71">            String[] split = line.split(&quot;,&quot;);</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">            for (String keyValue : split) {</span>
<span class="nc" id="L73">                keyValue = keyValue.trim();</span>
                // If entry is tne name of a disk, this is beginning of new
                // output for that disk.
<span class="nc bnc" id="L76" title="All 2 branches missed.">                if (diskMap.keySet().contains(keyValue)) {</span>
                    // First, if we have existing output from previous,
                    // update
<span class="nc bnc" id="L79" title="All 2 branches missed.">                    if (!disk.isEmpty()) {</span>
<span class="nc" id="L80">                        updateStore(diskMap.get(disk), model, vendor, product, serial, size);</span>
                    }
                    // Reset values for next iteration
<span class="nc" id="L83">                    disk = keyValue;</span>
<span class="nc" id="L84">                    model = &quot;&quot;;</span>
<span class="nc" id="L85">                    vendor = &quot;&quot;;</span>
<span class="nc" id="L86">                    product = &quot;&quot;;</span>
<span class="nc" id="L87">                    serial = &quot;&quot;;</span>
<span class="nc" id="L88">                    size = 0L;</span>
<span class="nc" id="L89">                    continue;</span>
                }
                // Otherwise update variables
<span class="nc bnc" id="L92" title="All 2 branches missed.">                if (keyValue.startsWith(&quot;Model:&quot;)) {</span>
<span class="nc" id="L93">                    model = keyValue.replace(&quot;Model:&quot;, &quot;&quot;).trim();</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">                } else if (keyValue.startsWith(&quot;Serial No:&quot;)) {</span>
<span class="nc" id="L95">                    serial = keyValue.replace(&quot;Serial No:&quot;, &quot;&quot;).trim();</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">                } else if (keyValue.startsWith(&quot;Vendor:&quot;)) {</span>
<span class="nc" id="L97">                    vendor = keyValue.replace(&quot;Vendor:&quot;, &quot;&quot;).trim();</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">                } else if (keyValue.startsWith(&quot;Product:&quot;)) {</span>
<span class="nc" id="L99">                    product = keyValue.replace(&quot;Product:&quot;, &quot;&quot;).trim();</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">                } else if (keyValue.startsWith(&quot;Size:&quot;)) {</span>
                    // Size: 1.23GB &lt;1227563008 bytes&gt;
<span class="nc" id="L102">                    String[] bytes = keyValue.split(&quot;&lt;&quot;);</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">                    if (bytes.length &gt; 1) {</span>
<span class="nc" id="L104">                        bytes = bytes[1].split(&quot;\\s+&quot;);</span>
<span class="nc" id="L105">                        size = ParseUtil.parseLongOrDefault(bytes[0], 0L);</span>
                    }
                }
            }
            // At end of output update last entry
<span class="nc bnc" id="L110" title="All 2 branches missed.">            if (!disk.isEmpty()) {</span>
<span class="nc" id="L111">                updateStore(diskMap.get(disk), model, vendor, product, serial, size);</span>
            }
<span class="nc" id="L113">        }</span>

        // Finally use kstat to get reads/writes
        // simultaneously populate result array
<span class="nc" id="L117">        HWDiskStore[] results = new HWDiskStore[diskMap.keySet().size()];</span>
<span class="nc" id="L118">        int index = 0;</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">        for (Entry&lt;String, HWDiskStore&gt; entry : diskMap.entrySet()) {</span>
<span class="nc" id="L120">            ArrayList&lt;String&gt; stats = ExecutingCommand.runNative(&quot;kstat -p ::&quot; + entry.getKey());</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">            for (String line : stats) {</span>
<span class="nc" id="L122">                String[] split = line.split(&quot;\\s+&quot;);</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">                if (split.length &lt; 2) {</span>
<span class="nc" id="L124">                    continue;</span>
                }
<span class="nc bnc" id="L126" title="All 2 branches missed.">                if (split[0].endsWith(&quot;:reads&quot;)) {</span>
<span class="nc" id="L127">                    entry.getValue().setReads(ParseUtil.parseLongOrDefault(split[1], 0L));</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">                } else if (split[0].endsWith(&quot;:writes&quot;)) {</span>
<span class="nc" id="L129">                    entry.getValue().setWrites(ParseUtil.parseLongOrDefault(split[1], 0L));</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">                } else if (split[0].endsWith(&quot;:nread&quot;)) {</span>
<span class="nc" id="L131">                    entry.getValue().setReadBytes(ParseUtil.parseLongOrDefault(split[1], 0L));</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">                } else if (split[0].endsWith(&quot;:nwritten&quot;)) {</span>
<span class="nc" id="L133">                    entry.getValue().setWriteBytes(ParseUtil.parseLongOrDefault(split[1], 0L));</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">                } else if (split[0].endsWith(&quot;:rtime&quot;)) {</span>
<span class="nc" id="L135">                    entry.getValue().setTransferTime((long) (ParseUtil.parseDoubleOrDefault(split[1], 0d) * 1000));</span>
                }
<span class="nc" id="L137">            }</span>
<span class="nc" id="L138">            results[index++] = entry.getValue();</span>
<span class="nc" id="L139">        }</span>

<span class="nc" id="L141">        return results;</span>
    }

    /**
     * Updates the HWDiskStore. If model name is nonempty it is used, otherwise
     * vendor+product are used for model
     * 
     * @param store
     *            A HWDiskStore
     * @param model
     *            model name, or empty string if none
     * @param vendor
     *            vendor name, or empty string if none
     * @param product
     *            product nmae, or empty string if none
     * @param serial
     *            serial number, or empty string if none
     * @param size
     *            size of the drive in bytes
     */
    private void updateStore(HWDiskStore store, String model, String vendor, String product, String serial, long size) {
<span class="nc bnc" id="L162" title="All 2 branches missed.">        store.setModel(model.isEmpty() ? (vendor + &quot; &quot; + product).trim() : model);</span>
<span class="nc" id="L163">        store.setSerial(serial);</span>
<span class="nc" id="L164">        store.setSize(size);</span>
<span class="nc" id="L165">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>