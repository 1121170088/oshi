<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WindowsOperatingSystem.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">oshi-core</a> &gt; <a href="index.source.html" class="el_package">oshi.software.os.windows</a> &gt; <span class="el_source">WindowsOperatingSystem.java</span></div><h1>WindowsOperatingSystem.java</h1><pre class="source lang-java linenums">/**
 * Oshi (https://github.com/oshi/oshi)
 *
 * Copyright (c) 2010 - 2017 The Oshi Project Team
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Maintainers:
 * dblock[at]dblock[dot]org
 * widdis[at]gmail[dot]com
 * enrico.bianchi[at]gmail[dot]com
 *
 * Contributors:
 * https://github.com/oshi/oshi/graphs/contributors
 */
package oshi.software.os.windows;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.sun.jna.Native;
import com.sun.jna.platform.win32.Advapi32;
import com.sun.jna.platform.win32.Advapi32Util;
import com.sun.jna.platform.win32.Advapi32Util.Account;
import com.sun.jna.platform.win32.Kernel32;
import com.sun.jna.platform.win32.WinDef.DWORD;
import com.sun.jna.platform.win32.WinNT;
import com.sun.jna.platform.win32.WinNT.HANDLE;
import com.sun.jna.platform.win32.WinNT.HANDLEByReference;

import oshi.jna.platform.windows.Psapi;
import oshi.jna.platform.windows.Psapi.PERFORMANCE_INFORMATION;
import oshi.software.common.AbstractOperatingSystem;
import oshi.software.os.FileSystem;
import oshi.software.os.NetworkParams;
import oshi.software.os.OSProcess;
import oshi.util.FormatUtil;
import oshi.util.ParseUtil;
import oshi.util.platform.windows.WmiUtil;
import oshi.util.platform.windows.WmiUtil.ValueType;

public class WindowsOperatingSystem extends AbstractOperatingSystem {

    private static final long serialVersionUID = 1L;

<span class="nc" id="L53">    private static final Logger LOG = LoggerFactory.getLogger(WindowsOperatingSystem.class);</span>

    // For WMI Process queries
<span class="nc" id="L56">    private static String processProperties = &quot;Name,ExecutablePath,CommandLine,ExecutionState,ProcessID,ParentProcessId&quot;</span>
            + &quot;,ThreadCount,Priority,VirtualSize,WorkingSetSize,KernelModeTime,UserModeTime,CreationDate&quot;
            + &quot;,ReadTransferCount,WriteTransferCount,__PATH,__PATH&quot;;
<span class="nc" id="L59">    private static ValueType[] processPropertyTypes = { ValueType.STRING, ValueType.STRING, ValueType.STRING,</span>
            ValueType.UINT32, ValueType.UINT32, ValueType.UINT32, ValueType.UINT32, ValueType.UINT32, ValueType.STRING,
            ValueType.STRING, ValueType.STRING, ValueType.STRING, ValueType.DATETIME, ValueType.UINT64,
            ValueType.UINT64, ValueType.PROCESS_GETOWNER, ValueType.PROCESS_GETOWNERSID };

    /*
     * Windows Execution States:
     */
    private static final int UNKNOWN = 0;
    private static final int OTHER = 1;
    private static final int READY = 2;
    private static final int RUNNING = 3;
    private static final int BLOCKED = 4;
    private static final int SUSPENDED_BLOCKED = 5;
    private static final int SUSPENDED_READY = 6;
    private static final int TERMINATED = 7;
    private static final int STOPPED = 8;
    private static final int GROWING = 9;

    /*
     * LastError
     */
    private static final int ERROR_ACCESS_DENIED = 5;

    static {
<span class="nc" id="L84">        enableDebugPrivilege();</span>
<span class="nc" id="L85">    }</span>

<span class="nc" id="L87">    public WindowsOperatingSystem() {</span>
<span class="nc" id="L88">        this.manufacturer = &quot;Microsoft&quot;;</span>
<span class="nc" id="L89">        this.family = &quot;Windows&quot;;</span>
<span class="nc" id="L90">        this.version = new WindowsOSVersionInfoEx();</span>
<span class="nc" id="L91">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public FileSystem getFileSystem() {
<span class="nc" id="L98">        return new WindowsFileSystem();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public OSProcess[] getProcesses(int limit, ProcessSort sort) {
<span class="nc" id="L106">        Map&lt;String, List&lt;Object&gt;&gt; procs = WmiUtil.selectObjectsFrom(null, &quot;Win32_Process&quot;, processProperties, null,</span>
                processPropertyTypes);
<span class="nc" id="L108">        List&lt;OSProcess&gt; procList = processMapToList(procs);</span>
<span class="nc" id="L109">        List&lt;OSProcess&gt; sorted = processSort(procList, limit, sort);</span>
<span class="nc" id="L110">        return sorted.toArray(new OSProcess[sorted.size()]);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public OSProcess getProcess(int pid) {
<span class="nc" id="L118">        Map&lt;String, List&lt;Object&gt;&gt; procs = WmiUtil.selectObjectsFrom(null, &quot;Win32_Process&quot;, processProperties,</span>
<span class="nc" id="L119">                String.format(&quot;WHERE ProcessId=%d&quot;, pid), processPropertyTypes);</span>
<span class="nc" id="L120">        List&lt;OSProcess&gt; procList = processMapToList(procs);</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">        return procList.isEmpty() ? null : procList.get(0);</span>
    }

    private List&lt;OSProcess&gt; processMapToList(Map&lt;String, List&lt;Object&gt;&gt; procs) {
<span class="nc" id="L125">        long now = System.currentTimeMillis();</span>
<span class="nc" id="L126">        List&lt;OSProcess&gt; procList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L127">        List&lt;String&gt; groupList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L128">        List&lt;String&gt; groupIDList = new ArrayList&lt;&gt;();</span>
        // All map lists should be the same length. Pick one size and iterate
<span class="nc" id="L130">        final int procCount = procs.get(&quot;Name&quot;).size();</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        for (int p = 0; p &lt; procCount; p++) {</span>
<span class="nc" id="L132">            OSProcess proc = new OSProcess();</span>
<span class="nc" id="L133">            proc.setName((String) procs.get(&quot;Name&quot;).get(p));</span>
<span class="nc" id="L134">            proc.setPath((String) procs.get(&quot;ExecutablePath&quot;).get(p));</span>
<span class="nc" id="L135">            proc.setCommandLine((String) procs.get(&quot;CommandLine&quot;).get(p));</span>
<span class="nc" id="L136">            proc.setProcessID(((Long) procs.get(&quot;ProcessID&quot;).get(p)).intValue());</span>
<span class="nc" id="L137">            proc.setParentProcessID(((Long) procs.get(&quot;ParentProcessId&quot;).get(p)).intValue());</span>
<span class="nc" id="L138">            proc.setUser((String) procs.get(&quot;PROCESS_GETOWNER&quot;).get(p));</span>
<span class="nc" id="L139">            proc.setUserID((String) procs.get(&quot;PROCESS_GETOWNERSID&quot;).get(p));</span>
            // Fetching group information incurs significant latency.
            // Only do for single-process queries
<span class="nc bnc" id="L142" title="All 2 branches missed.">            if (procCount == 1) {</span>
<span class="nc" id="L143">                final HANDLE pHandle = Kernel32.INSTANCE.OpenProcess(</span>
<span class="nc" id="L144">                        WinNT.PROCESS_QUERY_INFORMATION | WinNT.PROCESS_VM_READ, false, proc.getProcessID());</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">                if (pHandle != null) {</span>
<span class="nc" id="L146">                    final HANDLEByReference phToken = new HANDLEByReference();</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">                    if (Advapi32.INSTANCE.OpenProcessToken(pHandle, WinNT.TOKEN_DUPLICATE | WinNT.TOKEN_QUERY,</span>
                            phToken)) {
<span class="nc" id="L149">                        Account[] accounts = Advapi32Util.getTokenGroups(phToken.getValue());</span>
                        // get groups
<span class="nc" id="L151">                        groupList.clear();</span>
<span class="nc" id="L152">                        groupIDList.clear();</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">                        for (Account account : accounts) {</span>
<span class="nc" id="L154">                            groupList.add(account.name);</span>
<span class="nc" id="L155">                            groupIDList.add(account.sidString);</span>
                        }
<span class="nc" id="L157">                        proc.setGroup(FormatUtil.join(&quot;,&quot;, groupList));</span>
<span class="nc" id="L158">                        proc.setGroupID(FormatUtil.join(&quot;,&quot;, groupIDList));</span>
<span class="nc" id="L159">                    } else {</span>
<span class="nc" id="L160">                        int error = Kernel32.INSTANCE.GetLastError();</span>
                        // Access denied errors are common and will silently
                        // fail
<span class="nc bnc" id="L163" title="All 2 branches missed.">                        if (error != ERROR_ACCESS_DENIED) {</span>
<span class="nc" id="L164">                            LOG.error(&quot;Failed to get process token for process {}: {}&quot;, proc.getProcessID(),</span>
<span class="nc" id="L165">                                    Kernel32.INSTANCE.GetLastError());</span>
                        }
                    }
                }
<span class="nc" id="L169">                Kernel32.INSTANCE.CloseHandle(pHandle);</span>
            }
<span class="nc bnc" id="L171" title="All 7 branches missed.">            switch (((Long) procs.get(&quot;ExecutionState&quot;).get(p)).intValue()) {</span>
            case READY:
            case SUSPENDED_READY:
<span class="nc" id="L174">                proc.setState(OSProcess.State.SLEEPING);</span>
<span class="nc" id="L175">                break;</span>
            case BLOCKED:
            case SUSPENDED_BLOCKED:
<span class="nc" id="L178">                proc.setState(OSProcess.State.WAITING);</span>
<span class="nc" id="L179">                break;</span>
            case RUNNING:
<span class="nc" id="L181">                proc.setState(OSProcess.State.RUNNING);</span>
<span class="nc" id="L182">                break;</span>
            case GROWING:
<span class="nc" id="L184">                proc.setState(OSProcess.State.NEW);</span>
<span class="nc" id="L185">                break;</span>
            case TERMINATED:
<span class="nc" id="L187">                proc.setState(OSProcess.State.ZOMBIE);</span>
<span class="nc" id="L188">                break;</span>
            case STOPPED:
<span class="nc" id="L190">                proc.setState(OSProcess.State.STOPPED);</span>
<span class="nc" id="L191">                break;</span>
            case UNKNOWN:
            case OTHER:
            default:
<span class="nc" id="L195">                proc.setState(OSProcess.State.OTHER);</span>
                break;
            }
<span class="nc" id="L198">            proc.setThreadCount(((Long) procs.get(&quot;ThreadCount&quot;).get(p)).intValue());</span>
<span class="nc" id="L199">            proc.setPriority(((Long) procs.get(&quot;Priority&quot;).get(p)).intValue());</span>
<span class="nc" id="L200">            proc.setVirtualSize(ParseUtil.parseLongOrDefault((String) procs.get(&quot;VirtualSize&quot;).get(p), 0L));</span>
<span class="nc" id="L201">            proc.setResidentSetSize(ParseUtil.parseLongOrDefault((String) procs.get(&quot;WorkingSetSize&quot;).get(p), 0L));</span>
            // Kernel and User time units are 100ns
<span class="nc" id="L203">            proc.setKernelTime(ParseUtil.parseLongOrDefault((String) procs.get(&quot;KernelModeTime&quot;).get(p), 0L) / 10000L);</span>
<span class="nc" id="L204">            proc.setUserTime(ParseUtil.parseLongOrDefault((String) procs.get(&quot;UserModeTime&quot;).get(p), 0L) / 10000L);</span>
<span class="nc" id="L205">            proc.setStartTime((Long) procs.get(&quot;CreationDate&quot;).get(p));</span>
<span class="nc" id="L206">            proc.setUpTime(now - proc.getStartTime());</span>
<span class="nc" id="L207">            proc.setBytesRead((Long) procs.get(&quot;ReadTransferCount&quot;).get(p));</span>
<span class="nc" id="L208">            proc.setBytesWritten((Long) procs.get(&quot;WriteTransferCount&quot;).get(p));</span>
<span class="nc" id="L209">            procList.add(proc);</span>
        }
<span class="nc" id="L211">        return procList;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getProcessId() {
<span class="nc" id="L219">        return Kernel32.INSTANCE.GetCurrentProcessId();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getProcessCount() {
<span class="nc" id="L227">        PERFORMANCE_INFORMATION perfInfo = new PERFORMANCE_INFORMATION();</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (!Psapi.INSTANCE.GetPerformanceInfo(perfInfo, perfInfo.size())) {</span>
<span class="nc" id="L229">            LOG.error(&quot;Failed to get Performance Info. Error code: {}&quot;, Kernel32.INSTANCE.GetLastError());</span>
<span class="nc" id="L230">            return 0;</span>
        }
<span class="nc" id="L232">        return perfInfo.ProcessCount.intValue();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getThreadCount() {
<span class="nc" id="L240">        PERFORMANCE_INFORMATION perfInfo = new PERFORMANCE_INFORMATION();</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">        if (!Psapi.INSTANCE.GetPerformanceInfo(perfInfo, perfInfo.size())) {</span>
<span class="nc" id="L242">            LOG.error(&quot;Failed to get Performance Info. Error code: {}&quot;, Kernel32.INSTANCE.GetLastError());</span>
<span class="nc" id="L243">            return 0;</span>
        }
<span class="nc" id="L245">        return perfInfo.ThreadCount.intValue();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public NetworkParams getNetworkParams() {
<span class="nc" id="L253">        return new WindowsNetworkParams();</span>
    }

    /**
     * Enables debug privileges for this process, required for OpenProcess() to
     * get processes other than the current user
     */
    private static void enableDebugPrivilege() {
<span class="nc" id="L261">        HANDLEByReference hToken = new HANDLEByReference();</span>
<span class="nc" id="L262">        boolean success = Advapi32.INSTANCE.OpenProcessToken(Kernel32.INSTANCE.GetCurrentProcess(),</span>
                WinNT.TOKEN_QUERY | WinNT.TOKEN_ADJUST_PRIVILEGES, hToken);
<span class="nc bnc" id="L264" title="All 2 branches missed.">        if (!success) {</span>
<span class="nc" id="L265">            LOG.error(&quot;OpenProcessToken failed. Error: {}&quot; + Native.getLastError());</span>
<span class="nc" id="L266">            return;</span>
        }
<span class="nc" id="L268">        WinNT.LUID luid = new WinNT.LUID();</span>
<span class="nc" id="L269">        success = Advapi32.INSTANCE.LookupPrivilegeValue(null, WinNT.SE_DEBUG_NAME, luid);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (!success) {</span>
<span class="nc" id="L271">            LOG.error(&quot;LookupprivilegeValue failed. Error: {}&quot; + Native.getLastError());</span>
<span class="nc" id="L272">            return;</span>
        }
<span class="nc" id="L274">        WinNT.TOKEN_PRIVILEGES tkp = new WinNT.TOKEN_PRIVILEGES(1);</span>
<span class="nc" id="L275">        tkp.Privileges[0] = new WinNT.LUID_AND_ATTRIBUTES(luid, new DWORD(WinNT.SE_PRIVILEGE_ENABLED));</span>
<span class="nc" id="L276">        success = Advapi32.INSTANCE.AdjustTokenPrivileges(hToken.getValue(), false, tkp, 0, null, null);</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">        if (!success) {</span>
<span class="nc" id="L278">            LOG.error(&quot;AdjustTokenPrivileges failed. Error: {}&quot; + Native.getLastError());</span>
        }
<span class="nc" id="L280">        Kernel32.INSTANCE.CloseHandle(hToken.getValue());</span>
<span class="nc" id="L281">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>